#!/usr/bin/env node
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ts = require("typescript");
var util = require("util");
var fs = require("fs");
var path = require("path");
var commander = require("commander");
var error = require('commander.js-error');
var graphlib = require("graphlib");
// Get arguments
commander
    .version("0.0.1")
    .option('-o, --outfile <file>', 'Output file (omit for stdout)')
    .option('-l, --logfile <file>', 'Warnings file (omit for stderr)')
    .option('-q, --quiet', 'Suppress warnings')
    .option('--blacklist <list>', 'Comma-separated list of items to skip (see docs)')
    .option('--static-shadow', 'Block static members from being inherited by objects')
    .option('--debug-prefix <prefix>', 'Print additional info for symbols starting with...')
    .option('--debug-verbose', 'Dump entire object when printing debug information')
    .arguments("<file>")
    .parse(process.argv);
if (commander.args.length < 1)
    error("No file specified");
if (commander.args.length > 1)
    error("Too many files specified, at the moment the limit is 1");
if (commander.logfile && commander.quiet)
    error("Included both --quiet and --logfile options, which doesn't make sense");
// Get Typescript to load program
var program = ts.createProgram(commander.args, {});
var sourceFiles = program.getSourceFiles();
if (sourceFiles.length <= 1)
    error("File not found");
var typeChecker = program.getTypeChecker();
// Initialize output
var warn = null;
var write = null;
var writeBuild = ""; // Only used if commander.outfile
// Assign "write" function
if (commander.outfile) {
    // Before doing anything, make a best guess as to whether we can write the file.
    function accessSync(path, mode) {
        try {
            fs.accessSync(path, mode);
            return true;
        }
        catch (_) {
            return false;
        }
    }
    var checkPath = commander.outfile;
    if (!accessSync(checkPath, fs.F_OK))
        checkPath = path.dirname(commander.outfile);
    if (!accessSync(checkPath, fs.W_OK))
        error("Can not write output file " + commander.outfile);
    // TODO: Technically I guess best practice is to write to a temp file then move it in place at the end
    write = function (s) { writeBuild += s; writeBuild += "\n"; };
}
else {
    write = console.log.bind(console);
}
// Assign "warn" function
if (commander.quiet) {
    warn = function () {
        var X = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            X[_i - 0] = arguments[_i];
        }
    };
}
else if (commander.logfile) {
    var warnLogFile_1 = fs.openSync(commander.logfile, "w");
    warn = function (s) { fs.writeSync(warnLogFile_1, s + "\n"); };
}
else {
    warn = console.warn.bind(console);
}
write("# Generated by dts2nim script");
write("# Source files:");
for (var _i = 0, sourceFiles_1 = sourceFiles; _i < sourceFiles_1.length; _i++) {
    var sourceFile_1 = sourceFiles_1[_i];
    write("#     " + sourceFile_1.fileName);
}
write("");
write("when not defined(js) and not defined(Nimdoc):");
write("  {.error: \"This module only works on the JavaScript platform\".}");
write("");
// Support
// Note I don't use Set/Map due to weirdness around TypeScript not expecthing them present in ES5
function emptyMap() { return Object.create(null); }
var blacklist = emptyMap();
for (var _a = 0, _b = [
    // Does not make sense outside Javascript
    "static:prototype",
    // Can't translate without namespace collision handling
    "Element.webkitRequestFullScreen", "HTMLVideoElement.webkitEnterFullscreen", "HTMLVideoElement.webkitExitFullscreen",
    "static:Event.target", "static:Performance.navigation", "static:Performance.timing",
    "MSAppAsyncOperation.ERROR", "MSWebViewAsyncOperation.ERROR",
    // Can't translate without module support
    "class:CollatorOptions", "class:CSSRule", "class:DateTimeFormatOptions", "class:NumberFormatOptions", "class:Plugin",
].concat(commander.blacklist ? commander.blacklist.split(",") : []); _a < _b.length; _a++) {
    var key = _b[_a];
    blacklist[key] = true;
}
function blacklisted(nspace, name1, name2) {
    if (name2 === void 0) { name2 = null; }
    if (name2) {
        var combined = name1 + "." + name2;
        return blacklist[name2] || blacklist[nspace + ":" + name2]
            || blacklist[combined] || blacklist[nspace + ":" + combined];
    }
    else {
        return blacklist[name1] || blacklist[nspace + ":" + name1];
    }
}
// Assume enum is a bitfield, print all relevant bits.
// If "tight", assume enum values are exact values, not masks.
function enumBitstring(Enum, value, tight) {
    if (tight === void 0) { tight = false; }
    var result = "";
    for (var key in Enum) {
        var bit = Enum[key];
        if (typeof bit != "number" || !bit)
            continue;
        var masked = value & bit;
        if (tight ? (masked == bit) : masked) {
            if (result)
                result += "+";
            result += key;
        }
    }
    return result;
}
// Are all bits in b set in a?
function hasBit(a, b) { return (a & b) == b; }
function capitalizeFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
var reserved = emptyMap();
for (var _c = 0, _d = ["addr", "and", "as", "asm", "atomic", "bind", "block", "break", "case", "cast",
    "concept", "const", "continue", "converter", "defer", "discard", "distinct", "div", "do",
    "elif", "else", "end", "enum", "except", "export", "finally", "for", "from", "func", "generic",
    "if", "import", "in", "include", "interface", "is", "isnot", "iterator", "let", "macro",
    "method", "mixin", "mod", "nil", "not", "notin", "object", "of", "or", "out", "proc", "ptr",
    "raise", "ref", "return", "shl", "shr", "static", "template", "try", "tuple", "type", "using",
    "var", "when", "while", "with", "without", "xor", "yield"]; _c < _d.length; _c++) {
    var name_1 = _d[_c];
    reserved[name_1] = true;
}
// Convert TypeScript identifier to legal Nim identifier
// FIXME: Leaves open possibility of collisions
function identifierScrub(id, nameSpace) {
    if (nameSpace === void 0) { nameSpace = null; }
    if (nameSpace)
        id = nameSpace + capitalizeFirstLetter(id);
    id = id
        .replace(/_{2,}/, "_")
        .replace(/\$/, "zz");
    if (id[0] == '_')
        id = "z" + capitalizeFirstLetter(id.slice(1));
    if (reserved[id])
        id = "x" + capitalizeFirstLetter(id);
    return id;
}
function needIdentifierScrub(id, nameSpace) {
    if (nameSpace === void 0) { nameSpace = null; }
    return id != identifierScrub(id);
}
// Print the symbol that goes inside the quotes for an importc or importcpp
function importIdentifier(id, nameSpace) {
    if (nameSpace === void 0) { nameSpace = null; }
    if (nameSpace)
        id = nameSpace + "." + id;
    return id
        .replace(/\$/, "$$$$");
}
// Print {.importc.} with possible symbol correction
function importDirective(id, cpp, nameSpace) {
    if (cpp === void 0) { cpp = false; }
    if (nameSpace === void 0) { nameSpace = null; }
    return "importc" + (cpp ? "pp" : "") +
        (nameSpace || id != identifierScrub(id) ? ":\"" + importIdentifier(id, nameSpace) + "\"" : "");
}
function arrayFilter(x) {
    return x != null ? [x] : [];
}
function concatAll(x) {
    return [].concat.apply([], x);
}
function joinPrefixed(a, prefix) {
    return a.map(function (g) { return prefix + g; }).join("");
}
function tarjanResults(graph) {
    return graphlib.alg.tarjan(graph)
        .map(function (scc) { return scc.map(function (id) { return graph.node(id); }); });
}
// Exceptions
// This is needed to work around an issue in Typescript's ES5 generator
var CustomError = (function (_super) {
    __extends(CustomError, _super);
    function CustomError(message) {
        _super.call(this);
        this.message = message;
    }
    return CustomError;
}(Error));
var GenConstructFail = (function (_super) {
    __extends(GenConstructFail, _super);
    function GenConstructFail() {
        _super.apply(this, arguments);
    }
    return GenConstructFail;
}(CustomError));
// Raised on Typescript type the converter script doesn't know how to convert
var UnusableType = (function (_super) {
    __extends(UnusableType, _super);
    function UnusableType(type) {
        _super.call(this, "Cannot represent type: " + typeChecker.typeToString(type));
        this.type = type;
    }
    return UnusableType;
}(GenConstructFail));
function allDepends(gens) {
    return concatAll(gens.map(function (x) { return x.depends(); }));
}
function genJoin(a, joiner) {
    return a.map(function (g) { return g.declString(); }).join(joiner);
}
function declsFor(a) { return genJoin(a, "\n\n"); }
// FIXME: So the way unions are handled right now is a little weird. paramsGen returns an array of arrays, where each
// sub-array corresponds to all possible types that could appear at that position. That array of arrays is then passed
// in here, which generates an array of strings, corresponding to all possible type signatures that could be generated
// from treating the input as a list of sets.
//
// A better way to do ALL of this would for TypeGens to have a flag saying "are you compound?". Consumers of TypeGens
// that can't handle compoundness could throw when the flag is set, and SignatureTypeGens with compound components
// could themselves be compound.
function paramsFor(a) {
    var results = [''];
    for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
        var paramList = a_1[_i];
        var newResults = [];
        for (var _a = 0, paramList_1 = paramList; _a < paramList_1.length; _a++) {
            var param = paramList_1[_a];
            var paramString = param.declString();
            for (var _b = 0, results_1 = results; _b < results_1.length; _b++) {
                var existing = results_1[_b];
                var newResult = existing;
                if (newResult)
                    newResult += ", ";
                newResult += paramString;
                newResults.push(newResult);
            }
        }
        results = newResults;
    }
    return results;
}
// KLUDGE: genJoinPrefixed gets a nameSpace form and genJoin doesn't
function genJoinPrefixed(a, prefix, nameSpace) {
    if (nameSpace === void 0) { nameSpace = null; }
    return a.map(function (g) { return prefix + g.declString(nameSpace); }).join("");
}
var IdentifierGen = (function () {
    function IdentifierGen(name, type) {
        this.name = name;
        this.type = type;
    }
    IdentifierGen.prototype.declString = function () { throw new Error("Tried to print declaration for abstract identifier base class"); };
    IdentifierGen.prototype.depends = function () { return arrayFilter(this.type.dependKey()); };
    IdentifierGen.prototype.dependKey = function () { return this.name; }; // FIXME: Could variables live without these?
    return IdentifierGen;
}());
var VariableGen = (function (_super) {
    __extends(VariableGen, _super);
    function VariableGen() {
        _super.apply(this, arguments);
    }
    VariableGen.prototype.declString = function (nameSpace) {
        if (nameSpace === void 0) { nameSpace = null; }
        return ("var " + identifierScrub(this.name, nameSpace) + "* {." + importDirective(this.name, false, nameSpace) + ", nodecl.}: ")
            + this.type.typeString();
    };
    return VariableGen;
}(IdentifierGen));
var ParameterGen = (function (_super) {
    __extends(ParameterGen, _super);
    function ParameterGen() {
        _super.apply(this, arguments);
    }
    ParameterGen.prototype.declString = function () {
        return identifierScrub(this.name) + ": " + this.type.typeString();
    };
    return ParameterGen;
}(IdentifierGen));
var FieldGen = (function (_super) {
    __extends(FieldGen, _super);
    function FieldGen() {
        _super.apply(this, arguments);
    }
    FieldGen.prototype.declString = function () {
        return (identifierScrub(this.name) + "* {." + importDirective(this.name) + ".}")
            + (": " + this.type.typeString());
    };
    return FieldGen;
}(IdentifierGen));
var SignatureBase = (function () {
    function SignatureBase(params, returnType) {
        this.params = params;
        this.returnType = returnType;
    }
    SignatureBase.prototype.depends = function () {
        return concatAll(this.params.map(allDepends))
            .concat(arrayFilter(this.returnType.dependKey()));
    };
    return SignatureBase;
}());
var SignatureGen = (function (_super) {
    __extends(SignatureGen, _super);
    function SignatureGen(name, params, returnType) {
        _super.call(this, params, returnType);
        this.name = name;
    }
    SignatureGen.prototype.declString = function (nameSpace) {
        var _this = this;
        if (nameSpace === void 0) { nameSpace = null; }
        var fullParams = (this.owner ? [[new ParameterGen("self", this.owner)]] : [])
            .concat(this.params);
        return paramsFor(fullParams).map(function (paramString) {
            return ("proc " + identifierScrub(_this.name, nameSpace) + "*(" + paramString + ") : ")
                + _this.returnType.typeString()
                + (" {." + importDirective(_this.name, !!_this.owner, nameSpace) + ".}");
        }).join("\n");
    };
    SignatureGen.prototype.dependKey = function () { return this.name; };
    return SignatureGen;
}(SignatureBase));
var SignatureTypeGen = (function (_super) {
    __extends(SignatureTypeGen, _super);
    function SignatureTypeGen() {
        _super.apply(this, arguments);
    }
    SignatureTypeGen.prototype.declString = function () { throw new CustomError("Tried to emit a declaration for a procedure type"); };
    SignatureTypeGen.prototype.typeString = function () {
        var paramStrings = paramsFor(this.params);
        if (paramStrings.length != 1)
            throw new CustomError("Union-type arguments in a place this is not allowed");
        return "proc (" + paramStrings[0] + ") : " + this.returnType.typeString();
    };
    SignatureTypeGen.prototype.dependKey = function () { return null; };
    return SignatureTypeGen;
}(SignatureBase));
var ConstructorGen = (function () {
    function ConstructorGen(params) {
        this.params = params;
    }
    ConstructorGen.prototype.declString = function () {
        var _this = this;
        var scrubbed = identifierScrub(this.owner.name);
        var name = "new" + capitalizeFirstLetter(scrubbed);
        // Note: params.length check is to work around a bug which is fixed in newest Nim beta
        return paramsFor(this.params).map(function (paramString) {
            return ("proc " + name + "*(" + paramString + ") : " + scrubbed)
                + (" {.importcpp:\"new " + importIdentifier(_this.owner.name) + (_this.params.length ? "(@)" : "") + "\".}");
        }).join("");
    };
    ConstructorGen.prototype.depends = function () {
        return concatAll(this.params.map(allDepends));
    };
    ConstructorGen.prototype.dependKey = function () { return null; }; // Constructors dont stand alone
    return ConstructorGen;
}());
var ConstructorSpec = (function () {
    function ConstructorSpec() {
        this.constructors = [];
        this.foundConstructors = 0;
    }
    return ConstructorSpec;
}());
var LiteralTypeGen = (function () {
    function LiteralTypeGen(literal) {
        this.literal = literal;
    }
    LiteralTypeGen.prototype.declString = function () { throw new CustomError("Tried to emit a declaration for a core type"); };
    LiteralTypeGen.prototype.typeString = function () { return this.literal; };
    LiteralTypeGen.prototype.depends = function () { return []; };
    LiteralTypeGen.prototype.dependKey = function () { return null; };
    return LiteralTypeGen;
}());
var MemberSpec = (function () {
    function MemberSpec(fields, methods) {
        this.fields = fields;
        this.methods = methods;
    }
    return MemberSpec;
}());
var ClassInitPhase;
(function (ClassInitPhase) {
    ClassInitPhase[ClassInitPhase["Zero"] = 0] = "Zero";
    ClassInitPhase[ClassInitPhase["InheritanceInProgress"] = 1] = "InheritanceInProgress";
    ClassInitPhase[ClassInitPhase["Inheritance"] = 2] = "Inheritance";
    ClassInitPhase[ClassInitPhase["FullInProgress"] = 3] = "FullInProgress";
    ClassInitPhase[ClassInitPhase["Full"] = 4] = "Full";
    ClassInitPhase[ClassInitPhase["Invalid"] = 5] = "Invalid";
})(ClassInitPhase || (ClassInitPhase = {}));
var ClassGen = (function () {
    function ClassGen(name, abstract) {
        this.name = name;
        this.abstract = abstract;
        this.initPhase = ClassInitPhase.Zero;
    }
    ClassGen.prototype.init = function (constructors, fields, methods, staticFields, staticMethods) {
        this.constructors = constructors;
        this.members = new MemberSpec(fields, methods);
        this.statics = new MemberSpec(staticFields, staticMethods);
        for (var _i = 0, constructors_1 = constructors; _i < constructors_1.length; _i++) {
            var constructor = constructors_1[_i];
            constructor.owner = this;
        }
        for (var _a = 0, methods_1 = methods; _a < methods_1.length; _a++) {
            var method = methods_1[_a];
            method.owner = this;
        }
        this.initPhase = ClassInitPhase.Full;
    };
    ClassGen.prototype.declString = function () {
        return "type " + this.declStringInternal() + this.declStringExternal();
    };
    // The part of the declaration inside and outside the type is split out here for the benefit of CollectionGen
    ClassGen.prototype.declStringInternal = function () {
        return (identifierScrub(this.name) + "* {." + importDirective(this.name) + ".} = ref object of ")
            + (this.inherit ? identifierScrub(this.inherit.name) : "RootObj")
            + genJoinPrefixed(this.members.fields, "\n    "); // Four spaces
    };
    ClassGen.prototype.declStringExternal = function () {
        var fullMethods = this.members.methods;
        if (!this.abstract)
            fullMethods = this.constructors.concat(fullMethods);
        return genJoinPrefixed(fullMethods, "\n")
            + genJoinPrefixed(this.statics.fields, "\n", this.name)
            + genJoinPrefixed(this.statics.methods, "\n", this.name);
    };
    ClassGen.prototype.typeString = function () {
        return this.name;
    };
    ClassGen.prototype.depends = function () {
        return concatAll([this.members.fields, this.constructors, this.members.methods, this.statics.fields, this.statics.methods]
            .map(function (x) { return allDepends(x); })).concat(this.inherit ? [this.inherit.dependKey()] : []);
    };
    ClassGen.prototype.dependKey = function () { return this.name; };
    return ClassGen;
}());
// A group of mutually recursive types
var CollectionGen = (function () {
    function CollectionGen(gens) {
        this.gens = gens;
    }
    CollectionGen.prototype.declString = function () {
        var inheritance = new graphlib.Graph();
        var gens = [];
        for (var _i = 0, _a = this.gens; _i < _a.length; _i++) {
            var gen = _a[_i];
            if (gen instanceof ClassGen) {
                var key = gen.dependKey();
                inheritance.setNode(key, gen);
                if (gen.inherit)
                    inheritance.setEdge(key, gen.inherit.dependKey());
            }
            else {
                gens.push(gen); // This ought to be empty
            }
        }
        // Need to do a quick graph sort to make sure types are printed after their parents
        var groupedClassGens = tarjanResults(inheritance);
        var classGens = [];
        for (var _b = 0, groupedClassGens_1 = groupedClassGens; _b < groupedClassGens_1.length; _b++) {
            var group = groupedClassGens_1[_b];
            if (group.length > 1)
                warn("The following types were ignored because they appear to have an inheritance cycle:"
                    + (group.map(function (x) { return x.dependKey(); })).join(", ")); // This is a misuse of dependKey
            else if (group[0])
                classGens.push(group[0]);
        }
        return "type"
            + joinPrefixed(classGens.map(function (gen) { return gen.declStringInternal(); }), "\n  ") // Two spaces
            + classGens.map(function (gen) { return gen.declStringExternal(); }).join("")
            + genJoinPrefixed(gens, "\n");
    };
    // In theory these will not be used
    CollectionGen.prototype.depends = function () { return allDepends(this.gens); };
    CollectionGen.prototype.dependKey = function () { return this.gens.map(function (x) { return x.dependKey; }).join("-"); };
    return CollectionGen;
}());
var ClassExtraSpec = (function () {
    function ClassExtraSpec(constructors, statics, banFields) {
        this.constructors = constructors;
        this.statics = statics;
        this.banFields = banFields;
    }
    return ClassExtraSpec;
}());
function chainHasField(gen, name) {
    if (!gen)
        return false;
    for (var _i = 0, _a = gen.members.fields; _i < _a.length; _i++) {
        var field = _a[_i];
        if (field.name == name)
            return true;
    }
    return chainHasField(gen.inherit, name);
}
var GenVendor = (function () {
    function GenVendor() {
        this.classes = emptyMap();
    }
    GenVendor.prototype.variableGen = function (sym, tsType) {
        try {
            if (blacklisted("variable", sym.name))
                throw new GenConstructFail("Refusing to translate blacklisted variable " + sym.name);
            return new VariableGen(sym.name, vendor.typeGen(tsType));
        }
        catch (_e) {
            var e = _e;
            if (e instanceof UnusableType)
                throw new GenConstructFail("Could not translate variable " + sym.name + " because couldn't translate type " + typeChecker.typeToString(e.type));
            else
                throw e;
        }
    };
    GenVendor.prototype.paramsGen = function (syms) {
        var _this = this;
        return syms.map(function (sym) {
            var tsType = typeChecker.getTypeOfSymbolAtLocation(sym, sourceFile.endOfFileToken);
            // Unions are not supported by dts2nim overall, but they are supported in the special case of params
            var subTypes = tsType.flags & ts.TypeFlags.Union ?
                tsType.types :
                [tsType];
            // FIXME: This throws UnusableType but in the case of a union we could just skip unusable types
            return subTypes.map(function (subType) { return new ParameterGen(sym.name, _this.typeGen(subType)); });
        });
    };
    GenVendor.prototype.signatureGen = function (sym, callSignature) {
        return new SignatureGen(sym.name, this.paramsGen(callSignature.getParameters()), this.typeGen(callSignature.getReturnType()));
    };
    GenVendor.prototype.functionGen = function (sym, tsType) {
        if (blacklisted("variable", sym.name))
            throw new GenConstructFail("Refusing to translate blacklisted function " + sym.name);
        var result = [];
        var counter = 0;
        for (var _i = 0, _a = tsType.getCallSignatures(); _i < _a.length; _i++) {
            var callSignature = _a[_i];
            try {
                counter++;
                result.push(this.signatureGen(sym, callSignature));
            }
            catch (e) {
                if (e instanceof UnusableType)
                    warn(("Could not translate function " + sym.name)
                        + (counter > 0 ? ", call signature #" + counter : "")
                        + (" because tried to translate " + typeChecker.typeToString(tsType))
                        + (" but couldn't translate type " + typeChecker.typeToString(e.type)));
                else
                    throw e;
            }
        }
        return result;
    };
    GenVendor.prototype.signatureTypeGen = function (tsType, callSignature) {
        var params = this.paramsGen(callSignature.getParameters());
        // FIXME: At the moment unions aren't supported here.
        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
            var param = params_1[_i];
            if (param.length > 1)
                throw new UnusableType(tsType);
        }
        return new SignatureTypeGen(params, this.typeGen(callSignature.getReturnType()));
    };
    GenVendor.prototype.constructorSpec = function (declarations, ownerName) {
        if (ownerName === void 0) { ownerName = "(unknown)"; }
        var spec = new ConstructorSpec();
        for (var _i = 0, declarations_1 = declarations; _i < declarations_1.length; _i++) {
            var declaration = declarations_1[_i];
            spec.foundConstructors++;
            try {
                spec.constructors.push(new ConstructorGen(
                // Parameters exist on Declaration but are not publicly exposed. CHEAT:
                this.paramsGen(declaration.parameters.map(function (node) { return node.symbol; }))));
            }
            catch (_e) {
                var e = _e;
                if (e instanceof UnusableType)
                    warn(("Could not translate constructor #" + spec.foundConstructors + " on class " + ownerName)
                        + (" because couldn't translate type " + typeChecker.typeToString(e.type)));
                else
                    throw _e;
            }
        }
        return spec;
    };
    GenVendor.prototype.field = function (member, memberType, ownerName, inherit, isStatic) {
        if (isStatic === void 0) { isStatic = false; }
        var fields = [];
        var staticTag = isStatic ? "static " : "";
        try {
            if (blacklisted(isStatic ? "static" : "field", ownerName, member.name))
                warn("Refusing to translate blacklisted " + staticTag + "field " + member.name + " of class " + ownerName);
            else if (!(inherit && chainHasField(inherit, member.name)))
                fields.push(new (isStatic ? VariableGen : FieldGen)(member.name, this.typeGen(memberType)));
        }
        catch (_e) {
            var e = _e;
            if (e instanceof UnusableType)
                warn(("Could not translate " + staticTag + "field " + member.name + " on class " + ownerName)
                    + (" because couldn't translate type " + typeChecker.typeToString(e.type)));
            else
                throw _e;
        }
        return fields;
    };
    GenVendor.prototype.methods = function (member, memberType, ownerName, isStatic) {
        if (isStatic === void 0) { isStatic = false; }
        var methods = [];
        var staticTag = isStatic ? "static " : "";
        if (blacklisted(isStatic ? "static" : "field", ownerName, member.name)) {
            warn("Refusing to translate blacklisted " + staticTag + "method " + member.name + " of class " + ownerName);
        }
        else {
            var counter = 0;
            for (var _i = 0, _a = memberType.getCallSignatures(); _i < _a.length; _i++) {
                var callSignature = _a[_i];
                try {
                    counter++;
                    methods.push(this.signatureGen(member, callSignature));
                }
                catch (_e) {
                    var e = _e;
                    if (e instanceof UnusableType)
                        warn(("Could not translate " + staticTag + "method " + member.name + " on class " + ownerName)
                            + (counter > 0 ? ", call signature #" + counter : "")
                            + (" because tried to translate " + typeChecker.typeToString(memberType))
                            + (" but couldn't translate type " + typeChecker.typeToString(e.type)));
                    else
                        throw _e;
                }
            }
        }
        return methods;
    };
    GenVendor.prototype.collectionGen = function (gens) {
        return new CollectionGen(gens);
    };
    // Some notes on ClassGen init phases: Initialization happens in two phases.
    // Inheritance load: The class object is created. The inherit field is filled out. (This phase can fail.)
    // Full load: All fields are filled out, all member fields, methods, constructors etc are known. (This phase can't fail.)
    // When the symbol list is being iterated, each class is given a full load as it is reached.
    // If a field is full loaded, all its ancestors get full loads first (so constructors and fields can be compared)
    // If a class references another class in a field/method/etc, that class and all its ancestors get inheritance loads (so it is known if they failed).
    GenVendor.prototype.classGen = function (sym, tsType, fullLoad, abstract, classExtraSource) {
        if (fullLoad === void 0) { fullLoad = false; }
        if (abstract === void 0) { abstract = false; }
        if (classExtraSource === void 0) { classExtraSource = null; }
        function classType() {
            if (!tsType)
                tsType = typeChecker.getTypeOfSymbolAtLocation(sym, sourceFile.endOfFileToken);
            return tsType;
        }
        function classUnusableType() { return new UnusableType(classType()); }
        function classKind() { return abstract ? "interface" : "class"; }
        var name = sym.name;
        var result = this.classes[name];
        if (result) {
            if (result.initPhase == ClassInitPhase.Invalid)
                throw classUnusableType();
            if (result.initPhase == ClassInitPhase.Full
                || (!fullLoad && result.initPhase >= ClassInitPhase.InheritanceInProgress))
                return result;
            if (result.initPhase == ClassInitPhase.FullInProgress)
                throw new CustomError("Class ${name} somehow attempted to do a full init while a full init is already in progress. This should be impossible.");
        }
        if (!result) {
            result = new ClassGen(name, abstract);
            this.classes[name] = result;
        }
        try {
            if (result.initPhase < ClassInitPhase.Inheritance) {
                result.initPhase = ClassInitPhase.InheritanceInProgress;
                if (blacklisted("class", name)) {
                    warn("Refusing to translate blacklisted ${classKind()} " + name);
                    throw classUnusableType();
                }
                // Get superclass
                // Neither "heritageClauses" nor "types" are exposed. CHEAT:
                var heritageClauses = sym.declarations[0].heritageClauses;
                if (heritageClauses) {
                    var inheritSymbol = typeChecker.getSymbolAtLocation(heritageClauses[0].types[0].expression);
                    var inheritName = inheritSymbol.name;
                    var inherit = vendor.classGen(inheritSymbol, null);
                    if (inherit.initPhase < ClassInitPhase.Inheritance) {
                        warn(classKind() + " " + name + " has an inheritance loop with its ancestor " + inheritName);
                        throw classUnusableType();
                    }
                    result.inherit = inherit;
                }
                result.tempSymbol = sym;
                result.tempExtraSource = classExtraSource;
                result.initPhase = ClassInitPhase.Inheritance;
            }
            if (fullLoad)
                this.classInit(result);
            return result;
        }
        catch (_e) {
            var e = _e;
            result.initPhase = ClassInitPhase.Invalid;
            if (e instanceof UnusableType && e.type !== classType()) {
                warn(("Could not translate " + classKind() + " " + name + " because could not translate type ")
                    + typeChecker.typeToString(e.type));
                throw classUnusableType();
            }
            throw (e);
        }
    };
    GenVendor.prototype.classInit = function (result) {
        try {
            var name_2 = result.name;
            if (result.initPhase == ClassInitPhase.Full)
                return;
            else if (result.initPhase != ClassInitPhase.Inheritance)
                throw new CustomError("Attempted to perform full init on class " + name_2 + " while it is in a seemingly impossible state (" + result.initPhase + ", expected " + ClassInitPhase.Inheritance + ").");
            result.initPhase = ClassInitPhase.FullInProgress;
            if (result.inherit)
                this.classInit(result.inherit);
            var sym = result.tempSymbol;
            var classExtra = result.tempExtraSource ? result.tempExtraSource() : null;
            var fields = [];
            var methods = [];
            var staticFields = classExtra ? classExtra.statics.fields.slice() : [];
            var staticMethods = classExtra ? classExtra.statics.methods.slice() : [];
            var constructors = classExtra ? classExtra.constructors.constructors.slice() : [];
            var foundConstructors = classExtra ? classExtra.constructors.foundConstructors : 0;
            var extraBanFields = classExtra ? classExtra.banFields : emptyMap();
            // Iterate over class members
            // Public interface for SymbolTable lets you look up keys but not iterate them. CHEAT:
            for (var key in sym.members) {
                var member = sym.members[key];
                var memberType = typeChecker.getTypeOfSymbolAtLocation(member, sourceFile.endOfFileToken);
                // Member is a constructor
                if (hasBit(member.flags, ts.SymbolFlags.Constructor)) {
                    var spec = this.constructorSpec(member.declarations, name_2);
                    constructors = constructors.concat(spec.constructors);
                    foundConstructors += spec.foundConstructors;
                }
                else if (hasBit(member.flags, ts.SymbolFlags.Property)) {
                    if (extraBanFields[member.name])
                        continue;
                    fields = fields.concat(this.field(member, memberType, name_2, result.inherit));
                }
                else if (hasBit(member.flags, ts.SymbolFlags.Method)) {
                    if (extraBanFields[member.name])
                        continue;
                    methods = methods.concat(this.methods(member, memberType, name_2));
                }
                else {
                    warn("Could not figure out how to translate member " + member.name + " of class " + name_2);
                }
            }
            // CHEAT: Same cheat as members, see above
            for (var key in sym.exports) {
                var member = sym.exports[key];
                var memberType = typeChecker.getTypeOfSymbolAtLocation(member, sourceFile.endOfFileToken);
                // Static member is a field
                if (hasBit(member.flags, ts.SymbolFlags.Property)) {
                    staticFields = staticFields.concat(this.field(member, memberType, name_2, result.inherit, true));
                }
                else if (hasBit(member.flags, ts.SymbolFlags.Method)) {
                    staticMethods = staticMethods.concat(this.methods(member, memberType, name_2, true));
                }
                else {
                    warn("Could not figure out how to translate static member " + member.name + " of class " + name_2);
                }
            }
            // Get constructor
            if (!foundConstructors) {
                if (result.inherit && result.inherit.constructors) {
                    for (var _i = 0, _a = result.inherit.constructors; _i < _a.length; _i++) {
                        var constructor = _a[_i];
                        constructors.push(new ConstructorGen(constructor.params));
                    }
                }
                else {
                    constructors.push(new ConstructorGen([]));
                }
            }
            result.init(constructors, fields, methods, staticFields, staticMethods); // Will set init phase full
        }
        catch (e) {
            result.initPhase = ClassInitPhase.Invalid;
            throw e;
        }
        finally {
            result.tempSymbol = null;
            result.tempExtraSource = null;
        }
    };
    // A standard pattern in d.ts files is to mimic a class by means of a interface+variable combo
    // paired with a separate interface describing the class's constructor. The d.ts authors do
    // this instead of just declaring a class in order to get slightly different scope rules.
    // This script does not care about scope rules and can safely just collapse into a class.
    GenVendor.prototype.pseudoClassGen = function (sym, tsType, fullLoad) {
        var _this = this;
        if (fullLoad === void 0) { fullLoad = false; }
        var typeMembers = tsType.symbol.members;
        var constructor = typeMembers['__new'];
        // This is done in a thunk so that classGen can decide when or if to execute it
        var classExtraSource = function () {
            var name = sym.name;
            var typeIsSelf = tsType.symbol === sym;
            if (!typeIsSelf) {
                var constructorClass = _this.classGen(tsType.symbol, null);
                constructorClass.suppress = true;
            }
            var constructorSpec = constructor ? _this.constructorSpec(constructor.declarations, name) : new ConstructorSpec();
            var fields = [];
            var methods = [];
            var extraBanFields = emptyMap();
            // CHEAT: The members cheat again, see classGen
            for (var key in typeMembers) {
                var member = typeMembers[key];
                var memberType = typeChecker.getTypeOfSymbolAtLocation(member, sourceFile.endOfFileToken);
                // Member is a field
                if (hasBit(member.flags, ts.SymbolFlags.Property)) {
                    fields = fields.concat(_this.field(member, memberType, name, null, true)); // True because these are statics
                }
                else if (hasBit(member.flags, ts.SymbolFlags.Method)) {
                    methods = methods.concat(_this.methods(member, memberType, name, true));
                }
                else {
                    warn("Could not figure out how to translate member " + member.name + " of class " + name);
                }
            }
            // This is an attempt to prevent static fields inherited via prototype from unhelpfully appearing in object instances.
            if (commander.staticShadow) {
                for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
                    var field = fields_1[_i];
                    extraBanFields[field.name] = true;
                }
                if (typeIsSelf)
                    for (var _a = 0, methods_2 = methods; _a < methods_2.length; _a++) {
                        var method = methods_2[_a];
                        extraBanFields[method.name] = true;
                    }
            }
            return new ClassExtraSpec(constructorSpec, new MemberSpec(fields, methods), extraBanFields);
        };
        // Abstract if no constructor was found
        return this.classGen(sym, tsType, fullLoad, !constructor, classExtraSource);
    };
    GenVendor.prototype.typeGen = function (tsType) {
        if (tsType.flags & ts.TypeFlags.Number)
            return new LiteralTypeGen("float");
        if (tsType.flags & ts.TypeFlags.String)
            return new LiteralTypeGen("cstring");
        if (tsType.flags & ts.TypeFlags.Void)
            return new LiteralTypeGen("void");
        if (tsType.flags & ts.TypeFlags.Boolean)
            return new LiteralTypeGen("bool");
        if ((tsType.flags & (ts.TypeFlags.Class | ts.TypeFlags.Interface)) && tsType.symbol) {
            if (tsType.symbol.flags & (ts.SymbolFlags.BlockScopedVariable | ts.SymbolFlags.FunctionScopedVariable))
                return this.pseudoClassGen(tsType.symbol, tsType);
            return this.classGen(tsType.symbol, tsType);
        }
        if (tsType.flags & ts.TypeFlags.Anonymous) {
            var callSignatures = tsType.getCallSignatures();
            if (callSignatures.length == 1)
                return this.signatureTypeGen(tsType, callSignatures[0]);
        }
        throw new UnusableType(tsType);
    };
    return GenVendor;
}());
// Process input
var vendor = new GenVendor();
// Prefix `prefix` to every line of `string`, starting at line `startAtLine`
function linePrefix(str, prefix, startAtLine) {
    if (startAtLine === void 0) { startAtLine = 0; }
    var ary = str.split("\n");
    for (var idx in ary) {
        if (+idx >= startAtLine)
            ary[idx] = prefix + ary[idx];
    }
    return ary.join("\n");
}
// Return a string containing a commented-out string representation of an object,
// for tacking onto the end of an existing comment line
function debugVerboseEpilogue(obj) {
    if (!commander.debugVerbose)
        return "";
    return ", " + linePrefix(util.inspect(obj), "#         ", 1);
}
// Emit symbols
var sourceFile = sourceFiles[sourceFiles.length - 1];
var generators = [];
for (var _f = 0, _g = typeChecker.getSymbolsInScope(sourceFile.endOfFileToken, 0xFFFFFFFF); _f < _g.length; _f++) {
    var sym = _g[_f];
    var tsType = typeChecker.getTypeOfSymbolAtLocation(sym, sourceFile.endOfFileToken);
    // Handle --debugPrefix command
    if (commander.debugPrefix && sym.name.substr(0, commander.debugPrefix.length) == commander.debugPrefix)
        write("\n# " + sym.name + ": " + typeChecker.typeToString(tsType) +
            "\n#     Node:" + enumBitstring(ts.SymbolFlags, sym.flags, true) +
            debugVerboseEpilogue(sym) +
            "\n#     Type:" + enumBitstring(ts.TypeFlags, tsType.flags, true) +
            debugVerboseEpilogue(tsType));
    // Variable
    try {
        // Class
        if (hasBit(sym.flags, ts.SymbolFlags.Class)) {
            generators.push(vendor.classGen(sym, tsType, true));
        }
        else if (sym.flags & (ts.SymbolFlags.BlockScopedVariable | ts.SymbolFlags.FunctionScopedVariable)) {
            if (hasBit(sym.flags, ts.SymbolFlags.Interface))
                generators.push(vendor.pseudoClassGen(sym, tsType, true));
            else
                generators.push(vendor.variableGen(sym, tsType));
        }
        else if (hasBit(sym.flags, ts.SymbolFlags.Interface)) {
            generators.push(vendor.classGen(sym, tsType, true, true));
        }
        else if (hasBit(sym.flags, ts.SymbolFlags.Function)) {
            generators = generators.concat(vendor.functionGen(sym, tsType));
        }
        else {
            warn(("Could not figure out how to translate symbol " + sym.name + ":")
                + typeChecker.typeToString(tsType));
        }
    }
    catch (_e) {
        var e = _e;
        if (e instanceof GenConstructFail)
            warn(e.message);
        else
            throw e;
    }
}
// We now have a list of all symbols in alphabetical order. We need to sort them in order of
// relative dependency, and if any of the symbols are mutually recursive types we need to know that
// too. The tarjan algorithm (strongly connected components, reverse topological sort) does both
var dependencies = new graphlib.Graph();
for (var _h = 0, generators_1 = generators; _h < generators_1.length; _h++) {
    var gen = generators_1[_h];
    var key = gen.dependKey();
    dependencies.setNode(key, gen);
    for (var _j = 0, _k = gen.depends(); _j < _k.length; _j++) {
        var dep = _k[_j];
        dependencies.setEdge(key, dep);
    }
}
var groupedGenerators = tarjanResults(dependencies);
var sortedGenerators = [];
for (var _l = 0, groupedGenerators_1 = groupedGenerators; _l < groupedGenerators_1.length; _l++) {
    var group = groupedGenerators_1[_l];
    if (group.length > 1) {
        sortedGenerators.push(vendor.collectionGen(group.filter(function (gen) { return !gen.suppress; })));
    }
    else if (group[0]) {
        if (!group[0].suppress)
            sortedGenerators.push(group[0]);
    }
}
write(declsFor(sortedGenerators));
// We successfully reached the end, so if we have a file to write we can do that now
if (commander.outfile)
    fs.writeFileSync(commander.outfile, writeBuild);
